import random  # импортируем библиотеку для выбора случайных чисел

class BoardOutException(Exception):  # исключение, когда точка выстрела за пределами доски
    def __str__(self):
        return "Выстрел за пределы доски!"

class BoardBusyException(Exception):
    # исключение, когда в точку уже стреляли или она обведена в контуре убитого корабля, поэтому считается отстрелянной
    def __str__(self):
        return "Повторный выстрел в одну клетку, нужна другая клетка!"

class BoardShipErrorException(Exception):  # ошибка постановки корабля на доску
        pass

# определим класс точки
class Dot:
    def __init__(self, x, y):   # координаты
        self.x = x
        self.y = y

    def __eq__(self, other):  # сравнение точек
        return self.x == other.x and self.y == other.y

# определим класс корабля
class Ship:
    def __init__(self, length, start, orientation):
        # атрибуты корабля (длина, точка носа корабля, ориентация - горизонтпальная или вертикальная)
        self.start = start
        self.length = length
        self.orientation = orientation
        self.lives = length  # количество точек корабля, в которые еще не попали

    # получаем точки корабля методом, к которому можно обращаться, как к переменной
    @property
    def dots(self):
        ship_dots = [self.start]  # создаем список точек корабля
        a = self.start.x  # координата x точки
        b = self.start.y  # координата y точки

        for i in range(self.length - 1):  # перебираем в цикле длину корабля минус 1, так как range начинает с 0 перебор

            # если корабль вертикальный
            if self.orientation == 0:
                a = a + 1   # увеличиваем координату x, y остается без изменений
                ship_dots.append(Dot(a, b))  # добавляем в список точек корабля точку с этими координатами

            # если корабль горизонтальный
            elif self.orientation == 1:
                b = b + 1  # увеличиваем координату y, x остается без изменений
                ship_dots.append(Dot(a, b))  # добавляем в список точек корабля точку с этими координатами

        return ship_dots  # возвращается список точек корабля

# определим класс доски
class Board:
    def __init__(self, hid):
        # у класса доски есть обязательный атрибут, указывающий, скрыть доску или нет
        self.field = [["O"]*6 for i in range(6)]  # матрица поля
        self.list_ships = []  # список кораблей доски
        self.hid = hid  # видимость доски
        self.count_unshooten_ships = 7  # число неубитых кораблей доски
        self.busy_dots= []  # занятые расположенными кораблями или их контуром точки
        self.shooten_dots = []  # точки, в которые уже стреляли или которые в отрисованном контуре уже убитого корабля

    # добавляем корабль на доску
    def add_ship(self, ship):

        for s in ship.dots:   # перебираем точки корабля
            if self.out(s) or s in self.busy_dots:
                # если точка выходит за пределы или в списке занятых точек, то выбрасываем исключение
                raise BoardShipErrorException()

        for s in ship.dots: # перебираем точки корабля
            self.field[s.x - 1][s.y - 1] = "■" # отрисовываем каждую точку корабля на доске
            self.busy_dots.append(s) # добавляем точки на доску и в список занятых точек

        self.list_ships.append(ship) # добавляем корабль в список кораблей
        self.contour_ship(ship) # добавляем точки контура корабля в список точек, куда нельзя ставить корабль

    # У кораблей есть два вида контура, один контур (contour_ship) невидимый и нужен, чтобы знать контур корабля после
    # его расположения на рандомную доску, список точек этого контура нужен, чтобы не расположить в них другой корабль.
    # Второй контур (contour_shooten_ship) нужен, чтобы туда сложить точки убитого корабля и больше в них не стрелять.

    # добавляем в список занятых точек все точки контура корабля, чтобы туда не ставился другой корабль
    def contour_ship(self, ship):
        contourdots = [(-1, -1), (-1, 0) , (-1, 1), (0, -1), (0 , 1), (1, -1), (1, 0) , (1, 1)] # список,
        # соответствующий тому, насколько координаты каждой из 9 точек, окружающих конкретно взятую точку s,
        # меняют свои координаты относительно координат точки s
        for s in ship.dots: # перебираем точки корабля
            for sx, sy in contourdots: # перебираем попарно элементы кортежей в списке кортежей
                contour_dot = Dot(s.x + sx, s.y + sy) # создаем точку контура корабля

                # если точка контура не в списке текущего контура и не за пределами доски
                if contour_dot not in self.busy_dots and not self.out(contour_dot):
                        self.busy_dots.append(contour_dot)  # добавляем ее туда

    # добавляем в список отстрелянных точек точки контура убитого корабля,чтобы игрок не мог снова туда выстрелить
    def contour_shooten_ship(self, ship):
        contourdots = [(-1, -1), (-1, 0), (-1, 1),(0, -1), (0, 0), (0, 1), (1, -1), (1, 0), (1, 1)]
        # список,соответствующий тому, насколько координаты каждой из 9 точек, окружающих конкретно взятую точку s,
        # меняют свои координаты относительно координат точки s
        for s in ship.dots: # перебираем точки корабля
            for sx, sy in contourdots: # перебираем попарно элементы кортежей в списке кортежей
                contour_dot2 = Dot(s.x + sx, s.y + sy)# создаем точку контура убитого корабля

                # если точка контура не в списке текущего контура и не за пределами доски
                if contour_dot2 not in self.shooten_dots and not self.out(contour_dot2):
                    self.shooten_dots.append(contour_dot2)  # добавляем ее туда
                    self.field[contour_dot2.x - 1][contour_dot2.y - 1] = "."  # рисуем контур убитого корабля

    #выводим доску
    def print_board(self):
        printed_board ="  | 1 | 2 | 3 | 4 | 5 | 6 |"
        for i, row in enumerate(self.field):  # перебираем попарно номер и элемент
            printed_board = printed_board + f"\n{i + 1} | " + " | ".join(row) + " |"  # соединяем элементы в оформленное
        # поле для вывода в консоль

        #если доска должна быть скрыта, заменяем точки корабля, чтобы скрыть
        if self.hid == True:  # если атрибут указывает скрыть
            printed_board = printed_board.replace("■", "O")  # заменяем отрисованные точки корабля на "0", пустую клетку
        return printed_board  # выводим доску

    # проверяем, не выходит ли точка за пределы поля
    def out(self, s):
        if (0 < s.x < 7) and (0 < s.y < 7):  # если обе координаты больше 0 и меньше 7, то точка не выходит за поле
            return False
        else:
            return True # если условие выше не соблюдается, то выходит за поле

    # выстрел по доске
    def shot(self, s):
        if self.out(s): #если точка выходит за поле, выбрасывается исключение
            raise BoardOutException()

        if s in self.shooten_dots: # если точка в списке отстрелянных точек, то выбрасывается исключение и сообщение
            raise BoardBusyException()

        # добавляем точку выстрела в список отстрелянных точек, в которые нельзя стрелять
        self.shooten_dots.append(s)

        # проверяем корабли на доске на наличие точки выстрела
        for ship in self.list_ships: # перебираем корабли в списке кораблей
            if s in ship.dots: # если точка выстрела есть в списке точек корабля, то в корабль попали
                ship.lives = ship.lives - 1 # у корабля становится на одну меньше в списке точек, в которые не попадали
                print('Попадание по кораблю!')
                self.field[s.x - 1][s.y - 1] = "X" # эту точку отрисовываем как точку, в которую попали

                if ship.lives == 0: # если у корабля не осталось неотстрелянных точек
                    self.count_unshooten_ships = self.count_unshooten_ships - 1 # то число неубитых кораблей
                    # уменьшается на 1
                    self.contour_shooten_ship(ship) # убитый корабль обводится контуром
                    print("Корабль убит!")
                    return True
                else:
                    print("Корабль ранен!")
                    return True

        self.field[s.x - 1][s.y - 1] = "." # если точка выстрела не встретилась в точках кораблей доски, то игрок
        # не попал и ставим по координатам этой точки "."
        print("Мимо!")
        return False

# определяем родительский класс игрока
class Player:
    def __init__(self, player_board, opponent_board): # атрибуты своя доска и доска противника
        self.player_board = player_board
        self.opponent_board = opponent_board

    def ask(self): #метод определения точки, куда стрелять
        pass

    def move(self): # метод хода игрока
        while True:
            try:
                ask_dot = self.ask() # вызываем метод определения точки выстрела
                a = self.opponent_board.shot(ask_dot) # кладем в переменную результат выстрела по этой точке
                return a
            except Exception as e: # если встречается исключение, печатаем сообщение
                print(e)

# определяем дочерний класс соперника
class AI(Player):
    def ask(self): # метод определения точки выстрела для игрока-компьютера
        s = Dot(random.randint(1,6), random.randint(1,6)) # точка с рандомными координатами
        print(f"Ход компьютера: {s.x} {s.y}") # сообшение о ходе с этими координатами
        return s

# определяем дочерний класс пользователя
class User(Player):
    def ask(self): # метод определения точки выстрела для игрока-человека
        m = input("Введите координаты (строка, столбец через пробел): ").split() # вводит два числа через пробел,
        # преобразуем эту строку в список
        x = int(m[0])  # строчный элемент списка преобразуем в число
        y = int(m[1])  # строчный элемент списка преобразуем в число
        return Dot(x, y)  # получаем точку с полученными от пользователя координатами

# определяем класс игры
class Game:
    def __init__(self):
        user_board = self.random_board()  # рандомная доска с кораблями создается для пользователя
        ai_board = self.random_board()  # рандомная доска с кораблями создается для компьютера
        ai_board.hid = True  # доска компьютера должна быть спрятана
        user_board.hid = False  # доска пользователя не спрятана
        self.user = User(user_board, ai_board)  # создаем экземпляр класса User, это пользователь
        self.ai = AI(ai_board, user_board)  # создаем экземпляр класса AI, это компьютер

    # создаем доску и добавляем на нее корабли со случайно выбранной стартовой точкой
    def random_board(self):
        ship_size = [3, 2, 2, 1, 1, 1, 1]  # список длин кораблей доски
        board = Board(False)  # создаем доску
        count = 0  # счетчик
        for l in ship_size:  # перебираем длины кораблей доски
            while True:  # пока что бесконечный цикл
                count += 1  # счетчик увеличивается на 1
                if count > 1000:  # если число попыток больше 1000, то текущий метод запускаем с начала
                    return self.random_board()
                # создаем корабль с атрибутами (длина l, рандомная точка носа корабля, рандомная ориентация)
                ship = Ship(l, Dot(random.randint(1, 6), random.randint(1, 6)),random.randint(0, 1))
                try:  # если корабль ставится на доску, то цикл останавливается
                    board.add_ship(ship)
                    break
                except BoardShipErrorException:  # если не ставится, то цикл работает дальше
                        pass
        return board  # получаем доску с кораблями

    # приветствуем пользователя
    def greet(self):
        print('Здравствуйте!')
        print('Сыграйте в игру "Морской бой" с искусственным интеллектом.')
        print('Чтобы выбрать клетку, введите два числа через пробел (пример:x y), x - номер строки, y - номер столбца.')

    # метод цикла игры, нужен для ходов, если корабль ранен или убит, то игрок снова ходит, если все корабли
    # соперника убиты, это победа
    def loop(self):
        print("Ваша доска:")
        print(self.user.player_board.print_board())  # печатаем доску пользователя
        print("Доска соперника:")
        print(self.ai.player_board.print_board())  # печатаем доску компьютера
        i = 0  # счетчик
        while True:

            if i % 2 == 0:   # если в счетчике лежит число 0 или четное, то ходит пользователь
                a = self.user.move()  # ход пользователя
                print("Ваша доска:")
                print(self.user.player_board.print_board())  # печатаем доску пользователя
                print("Доска соперника:")
                print(self.ai.player_board.print_board())  # печатаем доску компьютера

            else:  # если в счетчике лежит число нечетное, то ходит компьютер
                a = self.ai.move()  # ход компьютера
                print("Ваша доска:")
                print(self.user.player_board.print_board())  # печатаем доску пользователя
                print("Доска соперника:")
                print(self.ai.player_board.print_board())  # печатаем доску компьютера

            if self.ai.player_board.count_unshooten_ships == 0:  # если неубитых кораблей не осталось на доске
                # компьютера, то выиграл пользователь
                print("Вы выиграли!")
                break

            if self.user.player_board.count_unshooten_ships == 0:  # если неубитых кораблей не осталось на доске
                # пользователя, то выиграл компьютер
                print("Соперник выиграл!")
                break

            if not a:  # если ход мимо, то он возвращает False в переменную a, и в счетчике i число увеличивается на 1
                i = i + 1  # счетчик увеличился на 1 и потом ход переходит к другому игроку

   #запуск игры
    def start(self):
        self.greet()  # вызываем метод приветствия
        self.loop()  # вызываем метод цикла игры, в нем игроки будуи делать ходы

seabattle = Game()  # создаем экземляр класса игры
seabattle.start()  # вызываем метод запуска игры